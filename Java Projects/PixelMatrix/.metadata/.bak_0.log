!SESSION 2023-09-15 17:25:14.939 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.css.swt.theme 4 0 2023-09-15 17:25:56.393
!MESSAGE /css/gef_dark.css
!STACK 0
java.io.FileNotFoundException: /css/gef_dark.css
	at org.eclipse.osgi.storage.url.bundleentry.Handler.findBundleEntry(Handler.java:55)
	at org.eclipse.osgi.storage.url.BundleResourceHandler.openConnection(BundleResourceHandler.java:182)
	at java.base/java.net.URL.openConnection(URL.java:1094)
	at org.eclipse.osgi.storage.url.BundleURLConverter.resolve(BundleURLConverter.java:55)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.core.internal.runtime.PlatformURLConverter.resolve(PlatformURLConverter.java:53)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:468)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:436)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:428)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.restore(ThemeEngine.java:624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.setCSSTheme(PartRenderingEngine.java:1417)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.initializeStyling(PartRenderingEngine.java:1324)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1050)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2023-09-15 17:25:56.945
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-15 17:25:56.945
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-15 17:25:56.945
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-15 17:26:02.645
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\tjaqu'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-09-17 22:11:03.127 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.css.swt.theme 4 0 2023-09-17 22:11:47.325
!MESSAGE /css/gef_dark.css
!STACK 0
java.io.FileNotFoundException: /css/gef_dark.css
	at org.eclipse.osgi.storage.url.bundleentry.Handler.findBundleEntry(Handler.java:55)
	at org.eclipse.osgi.storage.url.BundleResourceHandler.openConnection(BundleResourceHandler.java:182)
	at java.base/java.net.URL.openConnection(URL.java:1094)
	at org.eclipse.osgi.storage.url.BundleURLConverter.resolve(BundleURLConverter.java:55)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.core.internal.runtime.PlatformURLConverter.resolve(PlatformURLConverter.java:53)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:468)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:436)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:428)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.restore(ThemeEngine.java:624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.setCSSTheme(PartRenderingEngine.java:1417)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.initializeStyling(PartRenderingEngine.java:1324)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1050)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2023-09-17 22:11:47.631
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-17 22:11:47.631
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-17 22:11:47.632
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-17 22:11:52.892
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\tjaqu'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-09-19 17:54:54.019 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.css.swt.theme 4 0 2023-09-19 17:55:55.890
!MESSAGE /css/gef_dark.css
!STACK 0
java.io.FileNotFoundException: /css/gef_dark.css
	at org.eclipse.osgi.storage.url.bundleentry.Handler.findBundleEntry(Handler.java:55)
	at org.eclipse.osgi.storage.url.BundleResourceHandler.openConnection(BundleResourceHandler.java:182)
	at java.base/java.net.URL.openConnection(URL.java:1094)
	at org.eclipse.osgi.storage.url.BundleURLConverter.resolve(BundleURLConverter.java:55)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.core.internal.runtime.PlatformURLConverter.resolve(PlatformURLConverter.java:53)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:468)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:436)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:428)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.restore(ThemeEngine.java:624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.setCSSTheme(PartRenderingEngine.java:1417)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.initializeStyling(PartRenderingEngine.java:1324)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1050)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2023-09-19 17:55:56.262
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-19 17:55:56.262
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-19 17:55:56.262
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-19 17:56:01.883
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\tjaqu'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-09-20 22:27:48.052 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.css.swt.theme 4 0 2023-09-20 22:28:20.184
!MESSAGE /css/gef_dark.css
!STACK 0
java.io.FileNotFoundException: /css/gef_dark.css
	at org.eclipse.osgi.storage.url.bundleentry.Handler.findBundleEntry(Handler.java:55)
	at org.eclipse.osgi.storage.url.BundleResourceHandler.openConnection(BundleResourceHandler.java:182)
	at java.base/java.net.URL.openConnection(URL.java:1094)
	at org.eclipse.osgi.storage.url.BundleURLConverter.resolve(BundleURLConverter.java:55)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.core.internal.runtime.PlatformURLConverter.resolve(PlatformURLConverter.java:53)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:468)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:436)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:428)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.restore(ThemeEngine.java:624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.setCSSTheme(PartRenderingEngine.java:1417)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.initializeStyling(PartRenderingEngine.java:1324)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1050)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2023-09-20 22:28:20.532
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-20 22:28:20.532
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-20 22:28:20.532
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-20 22:28:27.362
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\tjaqu'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-09-20 23:06:37.979 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.css.swt.theme 4 0 2023-09-20 23:08:04.056
!MESSAGE /css/gef_dark.css
!STACK 0
java.io.FileNotFoundException: /css/gef_dark.css
	at org.eclipse.osgi.storage.url.bundleentry.Handler.findBundleEntry(Handler.java:55)
	at org.eclipse.osgi.storage.url.BundleResourceHandler.openConnection(BundleResourceHandler.java:182)
	at java.base/java.net.URL.openConnection(URL.java:1094)
	at org.eclipse.osgi.storage.url.BundleURLConverter.resolve(BundleURLConverter.java:55)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.core.internal.runtime.PlatformURLConverter.resolve(PlatformURLConverter.java:53)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:468)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:436)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:428)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.restore(ThemeEngine.java:624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.setCSSTheme(PartRenderingEngine.java:1417)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.initializeStyling(PartRenderingEngine.java:1324)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1050)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2023-09-20 23:08:04.669
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-20 23:08:04.669
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-20 23:08:04.669
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-20 23:08:13.630
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\tjaqu'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-09-21 22:54:43.158 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.css.swt.theme 4 0 2023-09-21 23:27:27.288
!MESSAGE /css/gef_dark.css
!STACK 0
java.io.FileNotFoundException: /css/gef_dark.css
	at org.eclipse.osgi.storage.url.bundleentry.Handler.findBundleEntry(Handler.java:55)
	at org.eclipse.osgi.storage.url.BundleResourceHandler.openConnection(BundleResourceHandler.java:182)
	at java.base/java.net.URL.openConnection(URL.java:1094)
	at org.eclipse.osgi.storage.url.BundleURLConverter.resolve(BundleURLConverter.java:55)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.core.internal.runtime.PlatformURLConverter.resolve(PlatformURLConverter.java:53)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:468)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:436)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:428)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.restore(ThemeEngine.java:624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.setCSSTheme(PartRenderingEngine.java:1417)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.initializeStyling(PartRenderingEngine.java:1324)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1050)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2023-09-21 23:27:27.628
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-21 23:27:27.628
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-21 23:27:27.628
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-21 23:27:33.619
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\tjaqu'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-09-23 13:48:27.329 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.css.swt.theme 4 0 2023-09-23 13:49:11.949
!MESSAGE /css/gef_dark.css
!STACK 0
java.io.FileNotFoundException: /css/gef_dark.css
	at org.eclipse.osgi.storage.url.bundleentry.Handler.findBundleEntry(Handler.java:55)
	at org.eclipse.osgi.storage.url.BundleResourceHandler.openConnection(BundleResourceHandler.java:182)
	at java.base/java.net.URL.openConnection(URL.java:1094)
	at org.eclipse.osgi.storage.url.BundleURLConverter.resolve(BundleURLConverter.java:55)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.core.internal.runtime.PlatformURLConverter.resolve(PlatformURLConverter.java:53)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:468)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:436)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:428)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.restore(ThemeEngine.java:624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.setCSSTheme(PartRenderingEngine.java:1417)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.initializeStyling(PartRenderingEngine.java:1324)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1050)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2023-09-23 13:49:12.243
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-23 13:49:12.243
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-23 13:49:12.243
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-23 13:49:16.519
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\tjaqu'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-09-23 19:59:10.965 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17.0.5
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.e4.ui.css.swt.theme 4 0 2023-09-23 19:59:51.970
!MESSAGE /css/gef_dark.css
!STACK 0
java.io.FileNotFoundException: /css/gef_dark.css
	at org.eclipse.osgi.storage.url.bundleentry.Handler.findBundleEntry(Handler.java:55)
	at org.eclipse.osgi.storage.url.BundleResourceHandler.openConnection(BundleResourceHandler.java:182)
	at java.base/java.net.URL.openConnection(URL.java:1094)
	at org.eclipse.osgi.storage.url.BundleURLConverter.resolve(BundleURLConverter.java:55)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.core.internal.runtime.PlatformURLConverter.resolve(PlatformURLConverter.java:53)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:468)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:436)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:428)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.restore(ThemeEngine.java:624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.setCSSTheme(PartRenderingEngine.java:1417)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.initializeStyling(PartRenderingEngine.java:1324)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1050)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2023-09-23 19:59:52.267
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-23 19:59:52.267
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-23 19:59:52.267
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-23 19:59:57.582
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\tjaqu'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:11.669
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / hi
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-23 20:52:11.672
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-23 20:52:11.673
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:11.734
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / hi
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:11.735
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:11.736
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:13.931
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-23 20:52:13.932
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-23 20:52:13.933
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:13.999
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:13.999
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:14.000
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.160
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-23 20:52:16.161
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-23 20:52:16.162
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.171
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.171
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.172
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.179
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.180
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.180
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.188
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.189
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.189
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.196
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.197
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.197
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.204
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.205
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.206
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.213
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.214
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.214
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.221
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.222
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.222
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.229
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.230
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.230
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.236
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.237
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.237
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.243
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.245
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.245
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.252
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.253
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.254
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.261
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.262
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.262
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.271
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.272
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.273
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.280
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.280
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.281
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.288
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.289
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.289
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.296
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.297
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.298
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.305
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.305
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.306
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.312
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.313
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.314
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.321
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.321
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.322
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.330
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.330
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.331
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.338
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.338
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.339
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:16.346
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:16.347
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:16.347
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:263)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:257)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:105)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:360)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:346)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.queue(DecorationScheduler.java:419)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:397)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:17.700
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:17.700
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:17.700
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:17.991
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:17.991
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:17.993
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:17.999
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-09-23 20:52:17.999
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:22.268
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					this.nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-23 20:52:22.268
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-23 20:52:22.268
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:22.333
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					this.nodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:22.333
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:22.334
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:23.058
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					this.renodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-23 20:52:23.058
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-23 20:52:23.058
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:23.137
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					this.renodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:23.139
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:23.139
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:27.639
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					this.renodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-23 20:52:27.640
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-23 20:52:27.641
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:27.650
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					this.renodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:27.650
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:27.650
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:28.759
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					this.renodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:28.761
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:28.761
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:28.855
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					this.renodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-23 20:52:28.855
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-23 20:52:28.856
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-23 20:52:29.095
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.io.PrintWriter;
import java.util.Scanner;

public class Image<T extends Comparable<T>> implements Iterable<Node<T>>
{
	private Node<T> head;
	private Node<T> tail;
	private int width;
	private int height;
	
	
	public Image(int width, int height)
	{
		this.width = width;
		this.height = height;
		
		Node<T> lastnode = null;
		Node<T> previousRowHead = null;
		
		for(int x = 0;x < height; ++x)
		{	
			//creates first row
			if(previousRowHead == null)
			{
				for(int y = 0;y < width; ++y)
				{
					Node<T> currentnode = new Node();
					
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					if(y == 0)
					{
						head = currentnode;
						previousRowHead = currentnode;
					}
					
					lastnode = currentnode;
				}
			}
			else
			{
				//creates rows 2 and onwards
				lastnode = null;
				Node<T> abovenode = null;
				Node<T> currentnode = new Node();
				previousRowHead.setDown(currentnode);
				abovenode = previousRowHead;
				currentnode.setUp(previousRowHead);
				
				for(int y = 0;y < width; ++y)
				{
					//sets left
					currentnode.setLeft(lastnode);
					
					//sets right
					if(currentnode.getLeft() != null)
					{
						currentnode.getLeft().setRight(currentnode);
					}
					
					//sets up
					currentnode.setUp(abovenode);
					
					//sets down
					abovenode.setDown(currentnode);
					
					if(y == 0)
					{
						previousRowHead = currentnode;
					}
					
					//process resetters
					abovenode = abovenode.getRight();
					lastnode = currentnode;
					
					currentnode = new Node();
				}
			}
		}
		tail = lastnode;
	}
	
	public int getHeight()
	{
		return height;
	}
	public int getWidth()
	{
		return width;
	}
	
	public Node<T> getHead()
	{
		return head;
	}
	
	public void insertRow(int index, T value)
	{
		Node<T> pointer = head;
		Node<T> lastnode = null;
		
		if(index == 0)
		{
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setUp(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setDown(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == 0)
				{
					head = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index < height)
		{
			for(int x = 0;x < index-1; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				currentnode.setUp(pointer);
				currentnode.setDown(pointer.getDown());
				pointer.setDown(currentnode);
				currentnode.getDown().setUp(currentnode);
				
				currentnode.setLeft(lastnode);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else if(index == height)
		{
			for(int x = 0;x < height-1; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				Node<T> currentnode = new Node();
				currentnode.setValue(value);
				
				pointer.setDown(currentnode);
				currentnode.setLeft(lastnode);
				currentnode.setUp(pointer);
				
				if(lastnode instanceof Node<T>)
				{
					lastnode.setRight(currentnode);
				}
				if(x == width-1)
				{
					tail = currentnode;
				}
				
				pointer = pointer.getRight();
				lastnode = currentnode;
			}
			height++;
		}
		else
		{
			throw new RuntimeException();
		}
	}
	
	public void removeColumn(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getRight();
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
		}
		else if(index < width-1)
		{
			System.out.println("i ran 1");
			
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			
			for(int x = 0;x < height; ++x)
			{
				pointer.getRight().setLeft(pointer.getLeft());
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer.setRight(null);
				pointer = pointer.getDown();
			}
			
		}
		else if(index == width-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getRight();
			}
			for(int x = 0;x < height; ++x)
			{
				if(x == height-1)
				{
					tail = pointer.getLeft();
				}
				
				pointer.getLeft().setRight(pointer.getRight());
				pointer.setLeft(null);
				pointer = pointer.getDown();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		width--;
	}
	
	private void removeRow(int index)
	{
		Node<T> pointer = head;
		
		if(index == 0)
		{
			head = pointer.getDown();
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
		}
		else if(index < height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			
			for(int x = 0;x < width; ++x)
			{
				pointer.getDown().setUp(pointer.getUp());
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer.setDown(null);
				pointer = pointer.getRight();
			}
			
		}
		else if(index == height-1)
		{
			for(int x = 0;x < index; ++x)
			{
				pointer = pointer.getDown();
			}
			for(int x = 0;x < width; ++x)
			{
				if(x == width-1)
				{
					tail = pointer.getUp();
				}
				
				pointer.getUp().setDown(pointer.getDown());
				pointer.setUp(null);
				pointer = pointer.getRight();
			}
		}
		else
		{
			throw new RuntimeException();
		}
		height--;
	}
	
	public int compress()
	{
		int nodesRemoved = 0;
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nodeIndexer = 0;
		boolean misMatchFound = false;
		
		while(imageIterator.hasNext())
		{
			nodeIndexer++;
			Node<T> node = imageIterator.next();
			
			if(node.getValue().compareTo(node.getRight().getValue()) == 0)
			{
				for(int x = 0;x < height; ++x)
				{
					if(node.getValue().compareTo(node.getRight().getValue()) != 0)
					{
						misMatchFound = true;
					}
				}
				if(!misMatchFound)
				{
					this.renodeIndexer / height
				}
			}
		}
			
		
		return nodesRemoved;
	}
	
	public void addBorder()
	{
		Node<T> innerpointer = head;
		Node<T> lastnode = null;
		Node<T> beginningnode = null;
		
		//top row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			if(x == 0)
			{
				beginningnode = currentnode;
			}
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setUp(currentnode);
			innerpointer.getUp().setDown(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setLeft(lastnode);
				currentnode.getLeft().setRight(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setLeft(currentnode);
				cornernode.getLeft().setRight(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getRight();
				lastnode = currentnode;
			}
		}
		//right row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setRight(currentnode);
			innerpointer.getRight().setLeft(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setUp(lastnode);
				currentnode.getUp().setDown(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setUp(currentnode);
				cornernode.getUp().setDown(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getDown();
				lastnode = currentnode;
			}
		}
		
		//bottom Row
		for(int x = 0;x < width; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setDown(currentnode);
			innerpointer.getDown().setUp(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setRight(lastnode);
				currentnode.getRight().setLeft(currentnode);
			}
			
			if(x == width-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setRight(currentnode);
				cornernode.getRight().setLeft(cornernode);
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getLeft();
				lastnode = currentnode;
			}
		}
		//left row
		for(int x = 0;x < height; ++x)
		{
			Node<T> currentnode = new Node<T>();
			
			currentnode.setValue(innerpointer.getValue());
			
			innerpointer.setLeft(currentnode);
			innerpointer.getLeft().setRight(innerpointer);
			
			if(lastnode != null)
			{
				currentnode.setDown(lastnode);
				currentnode.getDown().setUp(currentnode);
			}
			
			if(x == height-1)
			{
				Node<T> cornernode = new Node<T>();
				cornernode.setValue(currentnode.getValue());
				
				cornernode.setDown(currentnode);
				cornernode.getDown().setUp(cornernode);
				
				cornernode.setRight(beginningnode);
				cornernode.getRight().setLeft(cornernode);
				
				head = cornernode;
				
				lastnode = cornernode;
			}
			else
			{
				innerpointer = innerpointer.getUp();
				lastnode = currentnode;
			}
		}
		width = width + 2;
		height = height + 2;
	}
	
	public void removeBorder()
	{
		if(height < 3 || width < 3)
		{
			throw new RuntimeException();
		}
		else
		{
			this.removeRow(0);
			this.removeRow(height-1);
			this.removeColumn(0);
			this.removeColumn(width-1);
		}
	}
	
	public Image<T> maxFilter()
	{
		Image<T> returnImage = new Image<T>(width, height);
		
		Iterator<Node<T>> it = returnImage.iterator();
		Iterator<Node<T>> thisIt = this.iterator();
		
		while(thisIt.hasNext())
		{
			it.next().setValue((this.maxSurrounding(thisIt.next())));
		}
		
		return returnImage;
		
	}
	
	private T maxSurrounding(Node<T> node)
	{
		T returnval = null;
		
		//getting initial value
		if(node.getUp() instanceof Node)
		{
			returnval = node.getUp().getValue();
		}
		else if(node.getRight() instanceof Node)
		{
			returnval = node.getRight().getValue();
		}
		else if(node.getDown() instanceof Node)
		{
			returnval = node.getDown().getValue();
		}
		else if(node.getLeft() instanceof Node)
		{
			returnval = node.getLeft().getValue();
		}
		
		//checking all other values
		//1
		if(node.getUp() instanceof Node 
				&& node.getUp().getLeft() instanceof Node 
				&& node.getUp().getLeft().getValue() != null
				&& returnval.compareTo(node.getUp().getLeft().getValue()) < 0)
		{
			returnval = node.getUp().getLeft().getValue();
		}
		//2
		if(node.getUp() instanceof Node 
				&& node.getUp().getValue() != null
				&& returnval.compareTo(node.getUp().getValue()) < 0)
		{
			returnval = node.getUp().getValue();
		}
		//3
		if(node.getUp() instanceof Node 
				&& node.getUp().getRight() instanceof Node 
				&& node.getUp().getRight().getValue() != null
				&& returnval.compareTo(node.getUp().getRight().getValue()) < 0)
		{
			returnval = node.getUp().getRight().getValue();
		}
		//4
		if(node.getLeft() instanceof Node 
			&& node.getLeft().getValue() != null
			&& returnval.compareTo(node.getLeft().getValue()) < 0)
		{
			returnval = node.getLeft().getValue();
		}
		//6
		if(node.getRight() instanceof Node 
			&& node.getRight().getValue() != null
			&& returnval.compareTo(node.getRight().getValue()) < 0)
		{
			returnval = node.getRight().getValue();
		}
		//7
		if(node.getDown() instanceof Node 
				&& node.getDown().getLeft() instanceof Node 
				&& node.getDown().getLeft().getValue() != null
				&& returnval.compareTo(node.getDown().getLeft().getValue()) < 0)
		{
			returnval = node.getDown().getLeft().getValue();
		}
		//8
		if(node.getDown() instanceof Node 
				&& node.getDown().getValue() != null
				&& returnval.compareTo(node.getDown().getValue()) < 0)
		{
			returnval = node.getDown().getValue();
		}
		//9
		if(node.getDown() instanceof Node 
				&& node.getDown().getRight() instanceof Node 
				&& node.getDown().getRight().getValue() != null
				&& returnval.compareTo(node.getDown().getRight().getValue()) < 0)
		{
			returnval = node.getDown().getRight().getValue();
		}
		
		
		return returnval;
	}
	
	public Iterator<Node<T>> iterator()
	{
		return new ImageIterator(this);
	}
	
	public Iterator<Node<T>> iterator(Direction dir)
	{
		if(dir == Direction.HORIZONTAL)
		{
			return new ImageIterator(this);
		}
		else if(dir == Direction.VERTICAL)
		{
			return new Iterator<Node<T>>()
			{
				private Node<T> myhead = head;
				private Node<T> mycurrent = head;
				
				@Override
				public boolean hasNext() 
				{
					return mycurrent instanceof Node;
				}

				@Override
				public Node<T> next() 
				{
					Node<T> returnVal = mycurrent;
					
					if(mycurrent.getDown() instanceof Node)
					{
						mycurrent = mycurrent.getDown();
					}
					else
					{
						Node<T> pointer = mycurrent;
						
						for(int x = 0;x < height-1; ++x)
						{
							pointer = pointer.getUp();
						}
						mycurrent = pointer.getRight();
					}
					return returnVal;
				}
				
				public void remove()
				{
					throw new UnsupportedOperationException();
				}
	        };
		}
		else
		{
			return null;
		}
	}
	
	public String toString()
	{
		String returnString = "";
		
		Iterator<Node<T>> imageIterator = this.iterator(Direction.HORIZONTAL);
		
		int nextline = 0;
		
		while(imageIterator.hasNext())
		{
			returnString = returnString + imageIterator.next().getValue() + " ";
			
			nextline++;
			
			if(nextline % width == 0)
			{
				returnString = returnString + "\n";
			}
		}
		
		return returnString;
	}
	
    /**
        1. define a constructor that creates the two-dimensional doubly-linked list
        2. define the three getters as described in the specs
        3. define the two iterator methods as described in the specs
        4. define the six image manipulaton methods as described in the specs
    */

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2268)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3066)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3042)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3533)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3116)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
